---
title: "tentative title"
subtitle: 'GEO559'
author: Stephen C. Sanders
date: today
date-format: long
format:
  html:
    smooth-scroll: true
    toc: true
    toc-location: left
    toc-title: 'Table of Contents'
    code-fold: true
    code-tools: true
    embed-resources: true
    self-contained-math: true
execute:
  message: false
  warning: false
---

# Introduction and Literature Review

Buffalo, New York, emblematic of many Rust Belt cities, has faced significant economic decline, population loss, and elevated crime rates over recent decades (Klinenberg, 2002; Scorsone & Bateson, 2011; Kraus, 2004). Once a major industrial hub, Buffalo’s population has declined dramatically from its peak in the mid-20th century, a trend strongly tied to deindustrialization and regional economic restructuring (Hollander & Cahill, 2011; Ryan, 2015). Today, nearly 30% of Buffalo’s residents live below the poverty line (U.S. Census Bureau, 2020), and these concentrated socioeconomic disadvantages have been shown to be key contributors to elevated violent crime rates (Sampson et al., 1997; Krivo & Peterson, 1996).

In response to persistent crime, the Buffalo Police Department has implemented various crime prevention strategies, including the deployment of approximately 275 fixed surveillance cameras throughout the city (Open Data Buffalo, 2025). While public surveillance is increasingly used in urban policing strategies, research suggests mixed outcomes regarding their effectiveness: some studies indicate modest reductions in violent and property crimes, while others emphasize contextual limitations (Welsh & Farrington, 2009; Piza, 2018; Lum et al., 2019).

This study endeavors to identify significant predictors of violent crime in Buffalo, with particular focus on the presence of police surveillance cameras alongside a set of socioeconomic and demographic variables. A Generalized Linear Mixed Model (GLMM) was employed, allowing for both fixed effects (e.g., per capita income, poverty rate, racial composition) and random effects (e.g., spatial heterogeneity across census block groups), while a spatially lagged covariate was incorporated to account for neighborhood spillover effects (Anselin et al., 2000; Reich et al., 2006). An initial approach aggregating data over a 14-year period (2010–2023) revealed that every block group experienced at least one violent crime, thus necessitating a more nuanced model capable of isolating conditions under which violent crime is more likely to occur.

By integrating spatial dynamics, police surveillance infrastructure, and neighborhood-level socioeconomic predictors, this research seeks to offer a more comprehensive view of crime risks in Buffalo and contribute to the growing body of evidence on urban crime prevention strategies.

Understanding the multifaceted nature of violent crime necessitates an examination of both socioeconomic determinants and technological interventions and their relationship to violent crime. Research consistently indicates that socioeconomic factors such as poverty, unemployment, educational attainment, income inequality, overall economic disadvantage, and racial segregation are significant predictors of crime rates (Sampson and Groves, 1989; Krivo and Peterson, 1996). For instance, Wirdze (2024) found that higher levels of income inequality often lead to increased crime rates, particularly violent crimes like homicides and robberies. Similarly, the concept of "concentrated disadvantage," which encompasses factors like high poverty rates, unemployment, and single-parent households, has been linked to elevated crime levels in urban neighborhoods (Benson & Fox, 2004). This concept can potentially help explain the "law of crime concentration," which highlights that a small percentage of urban spaces account for a disproportionate amount of crime, emphasizing the need for place-based crime prevention strategies. These strategies typically involve installing surveillance cameras in an attempt to discourage crime. Systematic reviews and meta-analyses have found that CCTV surveillance is associated with a significant and modest decrease in crime, with the most consistent effects observed in car parks (Office of Justice Programs, 2019; Welsh & Farrington, 2009). However, the effectiveness of surveillance cameras can vary based on context and implementation. For example, a study by the Urban Institute (2019) indicated that while cameras can reduce crime, particularly property crimes and vehicle crimes in parking lots, the findings are mixed and context-dependent.

Spatial analysis has become an essential tool in crime modeling and general criminological research, allowing researchers to account for the geographic distribution of crime. Anselin et al. (2000) emphasized the importance of spatial econometric models in understanding crime dynamics, advocating for the inclusion of spatial lag variables to capture the influence of neighboring areas. Incorporating spatially lagged covariates into crime models helps address spatial autocorrelation, ensuring more accurate and reliable results (Park & Kim, 2014; Marotta, 2016). This approach acknowledges that crime in one area can be influenced by crime in neighboring areas, reflecting the interconnected nature of urban environments. The use of Generalized Linear Mixed Models (GLMMs) enables the integration of both fixed effects (e.g., socioeconomic variables) and random effects (e.g., unobserved heterogeneity across locations), providing a robust framework for analyzing complex crime and socioeconomic data (Bates et al., 2015; Wu & Li, 2024; Sariaslan et al., 2013). By combining socioeconomic data, surveillance measures, and spatial analysis, researchers can develop comprehensive models to better understand and predict crime patterns, ultimately informing more effective crime prevention strategies.

# Data and Study Area

## Data

The analysis looked at various demographic and socioeconomic variables along with presence of a police surveillance camera. Specifically, per capita income, poverty rate, percent of the 25 and over population with at least a bachelor degree (hereon referred to as "educational attainment"), local and neighboring percentages of the population who identified as black, percent of the block group within walking distance (0.25 miles) of a park (hereon referred to as "park proximity"), and time periods of 2010-2012, 2013-2015, 2016-2019, and 2020-2023 were used as predictors in the violent crime prediction model. Additionally, the block group GEOIDs were given a random intercept to account for unobserved unique conditions of each spatial unit.

There were 62,967 violent crimes that occurred in Buffalo between 2010 and 2023, which averages out to around 4,497 violent crimes per year over the 14-year span. By 2025, Buffalo Police Department had installed 275 surveillance cameras across the city. Of the cameras, 78 did not have an attached installation date. There were also 109 parks administered by the city, county, or state within city limit, all of which are least 0.25 acres in size.

Census data was pulled for years between 2010 and 2023. Block group-level data for 2013-2023 was gathered using the [tidycensus](https://walker-data.com/tidycensus/) package. Since the Census Bureau blocks access to block group data before 2013, data for 2010-2012 was pulled directly from the [IPUMS](https://data2.nhgis.org/main) data selection tool by the [NHGIS](https://www.nhgis.org/). The data was then downloaded and loaded using the [ipumsr](https://cran.r-project.org/web/packages/ipumsr/index.html) package. All of it originally came from American Community Survey (ACS) 5-year estimates calculated by the U.S. Census Bureau.

Exact data sources can be found in the references.

## Study Area

The study focuses on the 290 census block groups in Buffalo, New York as they have been delineated since 2020.

```{r study_area, message=F, warning=F, cache=T}
# get buffalo boundary and buffalo block group boundaries
buffalo <- 
  tigris::places(state = 'NY', cb = TRUE, year = 2020) %>%
  filter(NAME == 'Buffalo')

study_bgs <- 
  tigris::block_groups(state = 'NY', county = 'Erie', 
                       cb = TRUE, year = 2020) %>%
  .[data.frame(st_intersects(st_centroid(.), buffalo))$row.id,]

# plot Buffalo block groups as of 2020
buff_map <-
  ggplot() +
    geom_sf(data = study_bgs, 
            color = 'black', fill = NA, size = 2) +
    labs(title = 'Buffalo, New York Block Groups Since 2020') +
    theme_map()

buff_map
```

# Methods

## Processing Methods

The [tidyverse](https://www.tidyverse.org/) collection of packages was the primary tool used to process and manipulate a large amount of data. The [tigris](https://github.com/walkerke/tigris) package (specifically the *places* and *block_groups* functions) was used to pull Buffalo block groups to create a map of the study area and to pull block-level population and geometry data for use as the interpolation weights. The [sf](https://r-spatial.github.io/sf/) package was necessary to work with spatial features, including the block group-level ACS data. The plots and maps were created using [ggplot2](https://ggplot2.tidyverse.org/), and data tables were created using the [gt](https://gt.rstudio.com/) package. The interpolate_pw function of the tidycensus package was employed to create uniform block group boundaries over the 14-year period through population-weighted areal interpolation via centroid assignment (Walker, 2023).

The [terra](https://rspatial.github.io/terra/) package was used to convert the park proximity buffers to rasters and process them, and the [distanceto](https://robitalec.github.io/distance-to/) package allowed for the creation of a Euclidean distance (to park) raster over the city for each year. The resulting rasters were then the basis for the calculation of an average distance to park variable with the exact_extract() function from the [exactextractr](https://isciences.gitlab.io/exactextractr/) package. Park proximity was ultimately incorporated in the model by calculating the percentage of each block group that was covered by the walking distance proximity buffer for the relevant year as opposed to using the distance raster.

## Generalized Linear Mixed Model using lme4

A generalized linear mixed model was fitted using the [lme4](https://github.com/lme4/lme4/) package to assess violent crime risk across the 290 uniform block groups. The model attempted to predict the presence of violent crime in a block group using the block group's per capita income, poverty rate, educational attainment, local and neighboring percentages of the population who identified as black (to attempt to account for spatial dependence), park proximity, and time period as predictors. The spatially lagged covariate of black population was needed given the socioeconomic nature of this study, since socioeconomic phenomena tend to be clustered. Also, incorporating the GEOID of each block group as a random effect in a Generalized Linear Mixed Model (GLMM) effectively accounts for unobserved, time-invariant characteristics unique to each spatial unit, especially when observations are repeated over multiple years (Bolker et al., 2009). This approach controls for baseline differences across block groups, allowing fixed effects to capture temporal and socioeconomic predictors of violent crime. Such modeling techniques are well-supported in statistical literature, emphasizing their utility in handling repeated measures and nested data structures.

A GLMM regression model was originally fitted on a condensed dataset, where each row represented one block group and their average values over the course of the study time period. Every block group had at least one violent crime occur within the 14-year time period, so there was no second group (block groups without crime) to compare to. Another previous model attempt treated the year as a factor to observe more temporally granular violent crime risk changes, but the model faced issues with overparameterization and large standard errors in the coefficients. Creating a categorical predictor that groups the block groups into time periods was an appropriate work-around to solve issues with fitting while maintaining the ability to evaluate the change in risk since the earliest years of the study.

The glmer() function from the lme4 package was specifically used as it is widely utilized for fitting Generalized Linear Mixed Models (GLMMs), particularly in studies examining the influence of socioeconomic and demographic factors on various outcomes. For instance, in their comprehensive guide, Bates et al. (2015) detail the application of glmer() for modeling data with both fixed and random effects, emphasizing its flexibility in handling complex hierarchical structures. The bobyqa optimizer within the glmer() function was used to enhance model convergence and computational efficiency. The bobyqa optimizer, which stands for Bound Optimization BY Quadratic Approximation, is particularly effective for optimizing complex models with random effects, as it does not require gradient information and is well-suited for problems with bound constraints.

The [DHARMa](https://github.com/florianhartig/DHARMa) package was used for diagnostic tests to evaluate model assumptions after the model was fitted. The [spdep](https://r-spatial.github.io/spdep/) package was then used to check for spatial autocorrelation by running a Moran's I test.

## Data Processing

### Set Up and Load Data

Add some text here

#### Features Used in Analysis

The boundary and neighborhood boundaries of Buffalo, as well as the violent crimes, police surveillance cameras, and city-based parks were loaded and processed
    
```{r setup, message=F, warning=F, cache=T}
# import necessary libraries
library(tidyverse)
library(tidycensus)
library(tigris)
library(sf)
library(ipumsr)
library(terra)
library(fasterize)
library(distanceto)
library(rgee)
library(reticulate)
library(exactextractr)
library(units)
library(biscale)
library(performance)
library(lme4)
library(DHARMa)
library(spdep)
library(pROC)
library(RColorBrewer)
library(cowplot)
library(gt)

source('R/functions.R')

knitr::opts_chunk$set(echo = TRUE, # cache the results for quick compiling
                      fig.width = unit(18, 'cm'),
                      fig.height = unit(11, 'cm'))

# set options and get census api key
options(tigris_use_cache = TRUE)
terraOptions(progress = 0)
census_token = Sys.getenv("CENSUS_TOKEN")
census_api_key(census_token)


#######################################################################

# get buffalo city boundaries
buff_border <-
  read_csv('https://data.buffalony.gov/api/views/p4ak-r4fg/rows.csv?date=20250308&accessType=DOWNLOAD') %>%
  st_as_sf(wkt = 'Geometry', crs = 'EPSG:4269')

# get buffalo neighborhoods
buff_neighborhoods <- 
  read.csv('https://data.buffalony.gov/resource/ekfg-mtu8.csv') %>%
  st_as_sf(wkt = 'the_geom', crs = 'EPSG:4269') %>%
  rename(
    neighborhood_name = nbhdname,
    area_sqmi = sqmiles,
    geometry = the_geom
  ) %>%
  select(-c(nbhdnum, calcacres, objectid_1))

# import buffalo crimes
### 319,473 ROWS IN RAW FILE
###### 312,867 HAVE COORDINATES
######### 311,222 ARE WITHIN BUFFALO BOUNDARIES
crimes <- 
  read.csv('data/Crime_Incidents_20250303.csv', check.names = FALSE) %>%
  select(`Case Number`, `Incident Datetime`, `Incident Type Primary`, `Parent Incident Type`, 
         `Hour of Day`, `Day of Week`, Address, City, State, zip_code, 
         Latitude, Longitude, neighborhood, `Police District`) %>%
  mutate(
    Month = str_split(
      str_split(.$`Incident Datetime`, ' ', simplify = TRUE)[, 1], '/', simplify = TRUE)[, 1],
    Day = str_split(
      str_split(.$`Incident Datetime`, ' ', simplify = TRUE)[, 1], '/', simplify = TRUE)[, 2],
    Year = str_split(
      str_split(.$`Incident Datetime`, ' ', simplify = TRUE)[, 1], '/', simplify = TRUE)[, 3]
  ) %>%
  mutate_at('Year', as.numeric) %>%
  filter(Year >= 2006 & Year < 2024) %>%
  .[!((.$Latitude == 'UNKNOWN' | .$Longitude == 'UNKNOWN') | (.$Latitude == '' | .$Longitude == '')), ] %>%
  st_as_sf(coords = c('Longitude', 'Latitude'), crs = 'EPSG:4269')

buff_crimes <- crimes[data.frame(st_intersects(crimes, buff_border))$row.id,]

## 88,503 VIOLENT CRIMES
violent_crimes.buff <- buff_crimes %>% 
  filter(`Incident Type Primary` %in% 
           c('MURDER', 'CRIM NEGLIGENT HOMICIDE', 'MANSLAUGHTER', 'RAPE', 'AGGR ASSULT', 
           'AGG ASSULT ON P/OFFICER', 'ROBBERY', 'Robbery', 'ASSAULT', 'Assault', 
           'SEXUAL ABUSE', 'SODOMY', 'Other Sexual Offense'))

## 166,334 PROPERTY CRIMES
property_crimes.buff <- buff_crimes %>%
  filter(`Incident Type Primary` %in%
           c('UUV', 'THEFT OF SERVICES', 'LARCENY/THEFT', 'Theft', 'Theft of Vehicle', 'Breaking & Entering'))

# show bar graph of number of violent crimes per year between 2006 & 2023
ggplot(violent_crimes.buff, aes(Year)) + 
  geom_bar()

# show bar graph of number of property crimes per year between 2006 & 2023
ggplot(property_crimes.buff, aes(Year)) + 
  geom_bar()

# create line graph of homicides between 2006 and 2023 in Buffalo
homicide_types = c('MURDER', 'CRIM NEGLIGENT HOMICIDE', 'MANSLAUGHTER')

violent_crimes.buff %>% 
  st_drop_geometry %>% 
  filter(`Incident Type Primary` %in% homicide_types) %>% 
  group_by(Year) %>% 
  summarize(homicides = n()) %>%
  ungroup() %>%
  ggplot() +
    geom_line(aes(Year, homicides), color = 'blue') +
    geom_smooth(aes(Year, homicides), color = 'red', method = loess, se = FALSE) +
    ggtitle('Homicides in Buffalo, NY (2006 - 2023)') +
    ylab('Homicides') +
    scale_y_continuous(limits = c(25, 85), 
                       breaks = c(30, 40, 50, 60, 70, 80), 
                       labels = c(30, 40, 50, 60, 70, 80)) +
    scale_x_continuous(limits = c(2006, 2023), 
                       breaks = c(2006:2023),
                       labels = c(2006:2023)) +
    theme(plot.title = element_text(hjust = 0.5),
          panel.grid.major.y = element_blank())

# import bpd cameras data
### 275 TOTAL CAMERAS
##### 83 CAMERAS WITH VALID INSTALLED DATE
bpd_cameras <- 
  read.csv('https://data.buffalony.gov/api/views/gpj7-v6rr/rows.csv?date=20250304&accessType=DOWNLOAD',
           check.names = FALSE) %>%
  mutate(year = as.numeric(str_split(.$`Installed Date`, '/', simplify = TRUE)[, 3])) %>%
  st_as_sf(coords = c('X', 'Y'), crs = 'EPSG:4269')

bpd_cameras[grepl('2010', bpd_cameras$`Installed Date`), 'Installed Date'] <- 2010
bpd_cameras[grepl('2010', bpd_cameras$`Installed Date`), 'year'] <- 2010

# map of valid and invalid police cameras
bpd_cameras %>% 
  mutate(ifValid = ifelse(is.na(year), 0, 1)) %>% 
  ggplot() + 
    geom_sf(data = buff_border, color = 'black', fill = 'transparent') + 
    geom_sf(aes(color = as.factor(ifValid))) +
    scale_color_manual(
      name = 'Camera Validity', 
      labels = c('Invalid', 'Valid'), 
      values = c('darkgreen', 'pink')
    ) +
    theme_map()

# separate into dataframes for valid and invalid cameras
valid_cameras <- bpd_cameras %>% filter(!is.na(year))
invalid_cameras <- bpd_cameras %>% filter(is.na(year))

# create 0.25 mile buffer around all valid cameras
#cameras_buffer <- st_buffer(valid_cameras, dist = 402.336)

# import buffalo parks data
### 218 AREAS
##### 
####### 
buff_parks <- 
  read.csv('https://data.buffalony.gov/api/views/tmik-tgt9/rows.csv?date=20250304&accessType=DOWNLOAD',
                       check.names = FALSE) %>%
  st_as_sf(wkt = 'Geometry', crs = 'EPSG:4269') %>%
  filter(
    (`Park Class` %in% c('Major Park', 'Large Park', 'Midsize Park', 'Small Park', 'Parkway')) | (`Park Class` == 'Triangle' & Designated == 1)
  ) %>%
  mutate('Park Category' = 'City Park',
         Area_Sqmi = units::set_units(st_area(.), 'mi2'),
         Area_Acres = units::set_units(Area_Sqmi, 'acre')) %>%
  select('Park name', Address, Year, 'Park Class', 'Park Category', 'Maintained by',
         Neighborhood, 'Council District', Area_Sqmi, Area_Acres) %>%
  rename(Name = 'Park name',
         geometry = Geometry)

#buff_parks

# import nys parks, then find Buffalo-based state park and fill in relevant information
nys_parks <- 
  st_read('data/NYS_Park_Polygons.gpkg') %>% 
  st_transform(st_crs(buff_border))

nys_parks_in_buff.idx <- 
  nys_parks %>% 
  st_intersects(., buff_border) %>% data.frame() %>% .$`row.id`

nys_parks_in_buff <- 
  nys_parks[nys_parks_in_buff.idx,] %>% 
  filter(Category == 'State Park') %>%
  select(Category, Label, Original) %>% 
  mutate(
    Address = '1111 Fuhrmann Blvd', 
    'Park Class' = 'Major Park', 
    'Maintained by' = 'NYSOPRHP', 
    Neighborhood = 'Central', 
    'Council District' = 'South', 
    Area_Sqmi = units::set_units(st_area(.), 'mi2'), 
    Area_Acres = units::set_units(Area_Sqmi, 'acre')
  ) %>% 
  rename(
    Name = Label, Year = Original, 'Park Category' = Category, geometry = SHAPE
  ) %>% 
  mutate_at(vars(Year), as.numeric) %>%
  relocate('Park Category', .after = 'Park Class') %>% 
  relocate(Year, .after = Address)

#nys_parks_in_buff

# set relavent information for all 7 Buffalo parks under county jurisdiction
erie_park_addresses <- c('Aqua Ln', '3781 Main St', '20 Smith St', '1670 Seneca St', 
                          '11 Fuhrmann Blvd', 'Hertel Ave', '152 Bailey Ave')
erie_park_years <- c(2013, 1902, 2012, 1994, 1987, 1925, 1996)
erie_park_park_classes <- c('Small Park', 'Large Park', 'Small Park', 'Midsize Park',
                            'Large Park', 'Small Park', 'Small Park')
erie_park_neighborhoods <- c('Black Rock', 'University Heights', 'First Ward', 'Seneca-Cazenovia', 
                             'Central', 'Black Rock', 'Seneca-Cazenovia')
erie_park_districts <- c('North', 'University', 'Fillmore', 'Lovejoy', 
                         'South', 'North', 'Lovejoy')

# read in Buffalo-based county parks and add above info
erie_parks_in_buff <- 
  st_read('data/erie_county_parks_in_buffalo.gpkg') %>%
  st_make_valid() %>%
  select(NAME) %>%
  mutate(
    geom = st_simplify(geom, dTolerance = 0.001),
    Address = erie_park_addresses,
    Year = erie_park_years,
    'Park Class' = 'Major Park',
    'Park Category' = 'County Park',
    'Maintained by' = 'ECPD',
    Neighborhood = erie_park_neighborhoods,
    'Council District' = erie_park_districts,
    Area_Sqmi = units::set_units(st_area(.), 'mi2'),
    Area_Acres = units::set_units(Area_Sqmi, 'acre')
  ) %>%
  rename(Name = NAME, geometry = geom)

#erie_parks_in_buff

# bind all parks data together to create df of all Buffalo-based city, county, and state parks
# filter out parks that are less than 0.25 acres and all monumental/memorial parks
all_buff_parks <- 
  bind_rows(buff_parks, nys_parks_in_buff, erie_parks_in_buff) %>%
  filter(
    Area_Acres >= units::set_units(0.25, 'acre') & (!((grepl('Monument', Name) | (grepl('Memorial', Name)))))
  )

# add years to certain parks that don't currently have them
all_buff_parks[all_buff_parks$Name == 'Outer Harbor Parkway', 'Year'] <- 2013
all_buff_parks[all_buff_parks$Name == 'McCarthy Park', 'Year'] <- 1973
all_buff_parks[all_buff_parks$Name == 'Remembrance Park', 'Year'] <- 2003
all_buff_parks[all_buff_parks$Name == 'Peter St.', 'Year'] <- 2018
all_buff_parks[all_buff_parks$Name == 'Arlington Park', 'Year'] <- 1866
all_buff_parks[all_buff_parks$Name == 'Bristol Emslie Playground', 'Year'] <- 1998
all_buff_parks[all_buff_parks$Name == 'Genesee Gateway Triangle', 'Year'] <- 2008
all_buff_parks[all_buff_parks$Name == 'Unity Island', 'Year'] <- 2000

# 109 TOTAL VALID PARKS
#all_buff_parks

# map of parks by category
ggplot() +
  geom_sf(data = buff_border, color = 'black', fill = 'white') +
  geom_sf(data = all_buff_parks, aes(fill = `Park Category`)) +
  labs(title = 'Parks in Buffalo, NY by Category') +
  theme_map()
```

#### ACS Data

Add some text here

Load ACS data using tidycensus and ipumsr

```{r load_acs, message=F, warning=F, cache=T}
# load all nhgis files into lists
nhgis_data_files <- list.files('data/nhgis/vars', pattern = 'zip', full.names = TRUE)
nhgis_sf <- list.files('data/nhgis/spatial', pattern = 'zip', full.names = TRUE)

# process data for each year and store in its own df in nhgis_datasets
nhgis_datasets <- list()

for (year in 2010:2012) {
  # get data and sf files for year
  data_file <- nhgis_data_files[grepl(as.character(year), nhgis_data_files)]
  spatial_file <- nhgis_sf[grepl(as.character(year), nhgis_sf)]
  
  # load the data
  data <- read_nhgis(data_file, verbose = FALSE)
  
  # process relevant variables depending on the year
  if (year == 2010) {
    data <- 
      data %>% 
      rename(
        tot_pop = 42, 
        white_pop = 43, 
        black_pop = 44, 
        native_american_pop = 45, 
        asian_pop = 46, 
        pacific_islander_pop = 47, 
        other_race_pop = 48, 
        multiracial_pop = 49, 
        non_hispanic_pop = 53, 
        hispanic_pop = 54, 
        tot_pop_over_25 = 55, 
        per_capita_income = 125, 
        ppl_in_poverty = 91, 
        male_no_schooling = 57,
        male_hs_dip_equiv = 65, 
        male_some_college_lt_1yr = 66, 
        male_some_college_gt_1yr_no_deg = 67, 
        male_associates_deg = 68, 
        male_bachelors_deg = 69, 
        male_masters_deg = 70, 
        male_professional_deg = 71, 
        male_doctoral_deg = 72, 
        female_no_schooling = 74,
        female_hs_dip_equiv = 82, 
        female_some_college_lt_1yr = 83, 
        female_some_college_gt_1yr_no_deg = 84, 
        female_associates_deg = 85, 
        female_bachelors_deg = 86, 
        female_masters_deg = 87, 
        female_professional_deg = 88, 
        female_doctoral_deg = 89
      ) %>% 
      select(GEOID, YEAR, COUNTY, 42:49, 53:55, 125, 91, 57, 65:72, 74, 82:89) %>%
      mutate(
        no_schooling = male_no_schooling + female_no_schooling,
        high_school_dip_equiv = male_hs_dip_equiv + female_hs_dip_equiv,
        some_college_lt_1yr = male_some_college_lt_1yr + female_some_college_lt_1yr,
        some_college_gt_1yr_no_deg = male_some_college_gt_1yr_no_deg + female_some_college_gt_1yr_no_deg,
        associates_deg = male_associates_deg + female_associates_deg,
        bachelors_deg = male_bachelors_deg + female_bachelors_deg,
        masters_deg = male_masters_deg + female_masters_deg,
        professional_deg = male_professional_deg + female_professional_deg,
        doctoral_deg = male_doctoral_deg + female_doctoral_deg
      ) %>%
      select(-c(starts_with('male'), starts_with('female')))
  } else if (year == 2011) {
    data <- 
      data %>% 
      rename(
        tot_pop = 43, 
        white_pop = 44, 
        black_pop = 45, 
        native_american_pop = 46, 
        asian_pop = 47, 
        pacific_islander_pop = 48, 
        other_race_pop = 49, 
        multiracial_pop = 50, 
        non_hispanic_pop = 54, 
        hispanic_pop = 55, 
        tot_pop_over_25 = 56, 
        per_capita_income = 126, 
        ppl_in_poverty = 92, 
        male_no_schooling = 58,
        male_hs_dip_equiv = 66, 
        male_some_college_lt_1yr = 67, 
        male_some_college_gt_1yr_no_deg = 68, 
        male_associates_deg = 69, 
        male_bachelors_deg = 70, 
        male_masters_deg = 71, 
        male_professional_deg = 72, 
        male_doctoral_deg = 73, 
        female_no_schooling = 75,
        female_hs_dip_equiv = 83, 
        female_some_college_lt_1yr = 84, 
        female_some_college_gt_1yr_no_deg = 85, 
        female_associates_deg = 86, 
        female_bachelors_deg = 87, 
        female_masters_deg = 88, 
        female_professional_deg = 89, 
        female_doctoral_deg = 90
      ) %>% 
      select(GEOID, YEAR, COUNTY, 43:50, 54:56, 126, 92, 58, 66:73, 75, 83:90) %>%
      mutate(
        no_schooling = male_no_schooling + female_no_schooling,
        high_school_dip_equiv = male_hs_dip_equiv + female_hs_dip_equiv,
        some_college_lt_1yr = male_some_college_lt_1yr + female_some_college_lt_1yr,
        some_college_gt_1yr_no_deg = male_some_college_gt_1yr_no_deg + female_some_college_gt_1yr_no_deg,
        associates_deg = male_associates_deg + female_associates_deg,
        bachelors_deg = male_bachelors_deg + female_bachelors_deg,
        masters_deg = male_masters_deg + female_masters_deg,
        professional_deg = male_professional_deg + female_professional_deg,
        doctoral_deg = male_doctoral_deg + female_doctoral_deg
      ) %>%
      select(-c(starts_with('male'), starts_with('female')))
  } else {
    data <- 
      data %>% 
      rename(
        tot_pop = 43, 
        white_pop = 44, 
        black_pop = 45, 
        native_american_pop = 46, 
        asian_pop = 47, 
        pacific_islander_pop = 48, 
        other_race_pop = 49, 
        multiracial_pop = 50, 
        non_hispanic_pop = 54, 
        hispanic_pop = 55, 
        tot_pop_over_25 = 56, 
        per_capita_income = 116, 
        ppl_in_poverty = 82, 
        no_schooling = 57,
        high_school_diploma = 72,
        ged = 73,
        some_college_lt_1yr = 74,
        some_college_gt_1yr_no_deg = 75,
        associates_deg = 76,
        bachelors_deg = 77,
        masters_deg = 78,
        professional_deg = 79,
        doctoral_deg = 80
      ) %>% 
      select(GEOID, YEAR, COUNTY, 43:50, 54:56, 116, 82, 57, 72:80) %>%
      mutate(high_school_dip_equiv = high_school_diploma + ged) %>%
      select(-c(high_school_diploma, ged))
  }
  
  # get erie county block groups and simplify GEOID
  data <- 
    data %>%
    filter(COUNTY == 'Erie County') %>%
    relocate(GEOID, .before = YEAR) %>%
    mutate(GEOID = str_split(GEOID, '15000US', simplify=T)[,2],
           YEAR = str_split(YEAR, '-', simplify = TRUE)[,2]) %>%
    select(-COUNTY)
  
  # process sf file for year, then join to data by GEOID
  if (year == 2010) {
    sf <- read_ipums_sf(spatial_file, verbose=F) %>% 
      filter(COUNTYFP10 == '029') %>% 
      select(GEOID10) %>%
      rename(GEOID = GEOID10) %>%
      st_transform(crs = st_crs(buff_border))
    
    d <- inner_join(sf, data, by = 'GEOID') %>% 
      relocate(geometry, .after = last_col())
  } else {
    sf <- read_ipums_sf(spatial_file, verbose=F) %>% 
      filter(COUNTYFP == '029') %>% 
      select(GEOID) %>%
      st_transform(crs = st_crs(buff_border))
    
    d <- inner_join(sf, data, by = 'GEOID') %>% 
      relocate(geometry, .after = last_col())
  }
  
  # add year's dataset to list, then go to next list
  nhgis_datasets[[as.character(year)]] <- d
}

# combine nhgis erie county data into single dataframe
erie_blocks.nhgis <-
  bind_rows(nhgis_datasets) %>%
  rename(year = YEAR) %>%
  mutate_at(vars(per_capita_income, year), as.numeric) %>%
  mutate(
    area_sqmi = as.numeric(st_area(.)) * 3.861E-7,
    tot_pop_density = tot_pop / area_sqmi,
    pop_25plus_density = tot_pop_over_25 / area_sqmi,
    total_income = per_capita_income * tot_pop,
    some_college_no_deg = some_college_lt_1yr + some_college_gt_1yr_no_deg,
    bachelors_deg_at_least = bachelors_deg + masters_deg + professional_deg + doctoral_deg,
    less_than_bachelors_deg = tot_pop_over_25 - bachelors_deg_at_least,
    less_than_high_school_grad = tot_pop_over_25 - (high_school_dip_equiv + some_college_no_deg + bachelors_deg_at_least)
  ) %>%
  relocate(geometry, .after = last_col())

erie_blocks.nhgis[is.na(erie_blocks.nhgis)] <- 0

# get ACS block group data for pre-covid and post-covid years and store in separate dfs
erie_blocks.pre_covid <- 
  map(2013:2019, get_acs_block_group_data) %>%
  bind_rows()

erie_blocks.post_covid <- 
  map(2020:2023, get_acs_block_group_data) %>%
  bind_rows()

# separate buffalo block groups into their own dataframes
# make sure to get block groups that aren't included in original intersect
block_buff_intersects.nhgis <- 
  data.frame(
    st_intersects(st_centroid(erie_blocks.nhgis), buff_border)
  )$row.id

missing_blocks.nhgis <- which(erie_blocks.nhgis$GEOID %in% c(360290011003))

buff_blocks.nhgis <-
  erie_blocks.nhgis[c(block_buff_intersects.nhgis, missing_blocks.nhgis),] %>%
  st_make_valid()

block_buff_intersects.pre_covid <- 
  data.frame(
    st_intersects(
      st_centroid(erie_blocks.pre_covid), 
      buff_border
    )
  )$row.id

missing_blocks.pre_covid <- which(erie_blocks.pre_covid$GEOID %in% c(360290011003, 360290072021, 360290058022))

buff_blocks.pre_covid <- 
  erie_blocks.pre_covid[c(block_buff_intersects.pre_covid, missing_blocks.pre_covid),] %>%
  st_make_valid()

block_buff_intersects.post_covid <- data.frame(st_intersects(st_centroid(erie_blocks.post_covid), buff_border))$row.id

missing_blocks.post_covid <- which(erie_blocks.post_covid$GEOID %in% c(360290011003, 360290072021, 360290058022))

buff_blocks.post_covid <- 
  erie_blocks.post_covid[c(block_buff_intersects.post_covid, missing_blocks.post_covid),] %>%
  st_make_valid()

# combine nhgis (2010-2012) and pre-covid (2013-2019) dataframes into
# full Buffalo pre-covid dataframe, and remove empty rows
buff_blocks.pre_covid <- 
  bind_rows(buff_blocks.nhgis, buff_blocks.pre_covid) %>%
  filter(!is.na(year))
```

### Population-weighted areal interpolation

Add some text here

```{r interpolation, message=F, warning=F, cache=T}
# list of all variables pulled
all_vars <- c(
  'tot_pop', 'white_pop', 'black_pop', 'native_american_pop', 'asian_pop', 'pacific_islander_pop',
  'other_race_pop', 'multiracial_pop', 'non_hispanic_pop', 'hispanic_pop', 'ppl_in_poverty',
  'tot_pop_over_25', 'no_schooling', 'some_college_lt_1yr', 'some_college_gt_1yr_no_deg',
  'associates_deg', 'bachelors_deg', 'masters_deg', 'professional_deg', 'doctoral_deg',
  'high_school_dip_equiv', 'some_college_no_deg', 'bachelors_deg_at_least',
  'less_than_bachelors_deg', 'less_than_high_school_grad', 'per_capita_income'
)

# get erie county block boundaries in 2020, which was when block group boundaries changed
# then get blocks in buffalo boundary
# used to estimate population in each segment of new boundaries
erie_blocks.2020 <- tigris::blocks(state = 'NY', county = 'Erie', year = 2020)
buff_blocks.2020 <- st_intersection(erie_blocks.2020, buff_border, model = 'open')

# block group boundaries in 2020
buff_block_groups.2020 <- buff_blocks.post_covid %>% filter(year == 2020)

# list of pre-covid years
pre_covid_yrs <- unique(buff_blocks.pre_covid$year)

# empty list of interpolated block group boundary dataframes for each pre-covid year
# will bind rows after interpolation
pre_covid_data <- list()

# estimate data for years between 2013-2019 using block group boundaries in 2020-2023
# applies population-weighted areal interpolation technique (interpolation_pw)
for (i in pre_covid_yrs) {
  # get data for current year
  yr_df <- 
    buff_blocks.pre_covid[buff_blocks.pre_covid$year == i,] %>%
    select(-c(year, per_capita_income, tot_pop_density, 
              pop_25plus_density, area_sqmi))
  
  # apply population-weighted areal interpolation technique
  # to conform boundaries and estimate the data
  interpolated <- 
    yr_df %>%
    interpolate_pw(
      ., buff_block_groups.2020, 
      to_id = 'GEOID', 
      extensive = TRUE, 
      weights = buff_blocks.2020, 
      weight_column = 'POP20',
      weight_placement = 'centroid',
      crs = st_crs(buff_blocks.pre_covid)
    ) %>%
    mutate(
      year = as.numeric(i),
      per_capita_income = total_income / tot_pop,
      area_sqmi = as.numeric(st_area(.) * 3.861E-7),
      tot_pop_density = tot_pop / area_sqmi,
      pop_25plus_density = tot_pop_over_25 / area_sqmi
    )
  
  #
  pre_covid_data[[as.character(i)]] <- interpolated
}

# combine interpolated 2010-2019 (which now follow 2020 block group boundaries)
# with post-COVID data, also round interpolated data and remove a couple columns
buff_blocks <-
  bind_rows(pre_covid_data) %>%
  bind_rows(., buff_blocks.post_covid) %>%
  select(-total_income) %>%
  mutate(
    across(all_vars, ~ round(.)),
    pct_below_poverty = ppl_in_poverty / tot_pop,
    pct_bachelors_deg_at_least = bachelors_deg_at_least / tot_pop_over_25,
    pct_less_than_high_school_grad = less_than_high_school_grad / tot_pop_over_25,
    pct_white_pop = white_pop / tot_pop,
    pct_black_pop = black_pop / tot_pop,
    pct_hispanic_pop = hispanic_pop / tot_pop
  ) %>%
  relocate(year, .after = GEOID) %>%
  relocate(geometry, .after = last_col()) %>%
  relocate(area_sqmi, .before = geometry)
```

### Final Processing and Data Calculation

Add some text here

```{r final_calculations, message=F, warning=F, cache=T}
# initialize separate lists to hold avg_park_distance rasters and buffer rasters
avg_park_distance_rasters <- c()
buffer_rasters <- c()

# determine number of cameras in block group in year,
# as well as number of violent crimes and violent crime rate
# also process data in general in preparation for logistic regression analysis
buff_blocks <- 
  lapply(2010:2023, function(yr) {
    ##print(as.character(yr))
    
    # blocks in year
    yr_buff_blocks <- 
      buff_blocks %>% 
      filter(year == yr) %>% 
      st_transform(crs = proj_crs) %>%
      mutate(area_sqmi = as.numeric(units::set_units(st_area(.), 'mi2'))) %>%
      st_make_valid()
    
    # valid cameras in year
    cams <- 
      valid_cameras[valid_cameras$year <= yr,] %>% 
      st_transform(crs = proj_crs) %>%
      st_make_valid()
    
    # add remaining cameras without installation dates
    # after the year 2018
    if (year >= 2018) {
      cams <- bind_rows(cams, st_transform(bpd_cameras[is.na(bpd_cameras$year),], 
                                           crs = proj_crs))
      cams[is.na(cams)] <- 2018
    } else {
      cams <- cams
    }
    
    # get violent crimes in year
    crimes <- 
      violent_crimes.buff[violent_crimes.buff$Year == yr,] %>% 
      st_transform(crs = proj_crs) %>%
      st_make_valid()
    
    # number of cameras in each block
    cams_per_block <-
      st_join(
        yr_buff_blocks %>% select(GEOID),
        st_join(cams, yr_buff_blocks, join = st_within) %>%
          group_by(GEOID) %>%
          summarize(Num_Cameras = n(), .groups = 'drop'),
        suffix = c('', '_y')
      ) %>%
      select(-GEOID_y)
    
    # number of violent crimes in each block
    crimes_per_block <-
      st_join(
        yr_buff_blocks %>% select(GEOID),
        st_join(crimes, yr_buff_blocks, join = st_within) %>%
          group_by(GEOID) %>%
          summarize(num_violent_crimes = n(), .groups = 'drop'),
        suffix = c('', '_y')
      ) %>%
      select(-GEOID_y)
    
    # parks in the year
    parks_yr <- 
      all_buff_parks[all_buff_parks$Year <= yr,] %>% 
      st_transform(crs = proj_crs) %>%
      st_make_valid()
    
    # dissolved buffer of parks
    parks_buffer <- 
      st_buffer(parks_yr, dist = 402.336) %>%
      st_union() %>%
      st_make_valid() %>%
      st_transform(crs = proj_crs)
    
    # get extent using the buffalo block groups
    ext <- st_bbox(yr_buff_blocks)
    
    # create a temporary raster of the study area
    parks_temp_raster <- rast(
      extent = ext,
      resolution = 10,
      crs = proj_crs
    )
    
    # rasterize buffer (cells inside buffer = 1, outside = 0)
    # then add to buffer_rasters vector
    buffer_raster <- rasterize(vect(parks_buffer), parks_temp_raster, 
                               field = 1, background = 0, progress = 0)
    
    buffer_rasters[[as.character(yr)]] <- buffer_raster
    
    # calculate percent walking distance park proximity coverage
    pct_park_coverage <- exactextractr::exact_extract(buffer_raster, 
                                                      yr_buff_blocks, 
                                                      'mean', progress = 0)
    
    # create euclidean distance raster of park proximity buffer
    dist_raster <- distanceto::distance_raster(
      y = parks_yr %>% st_collection_extract('POLYGON'),
      cellsize = 30, 
      extent = ext, 
      check = FALSE,
      progress = 0
    )
    
    # calculate average distance to park in each block group,
    # then add raster to avg_park_distance_rasters vector
    avg_park_distances <- exactextractr::exact_extract(dist_raster, 
                                                       yr_buff_blocks, 
                                                       'mean', progress = 0)
    
    avg_park_distance_rasters[[as.character(yr)]] <- avg_park_distances
    
    # final joining back to year data and creating remaining variables
    # then return the data for the year
    return(
      yr_buff_blocks %>%
        st_join(cams_per_block, st_nearest_feature, suffix = c('', '_y')) %>%
        select(-GEOID_y) %>%
        st_join(crimes_per_block, st_nearest_feature, suffix = c('', '_y')) %>%
        select(-GEOID_y) %>%
        mutate(
          Num_Cameras = replace_na(Num_Cameras, 0),
          num_violent_crimes = replace_na(num_violent_crimes, 0),
          pct_park_proximity = pct_park_coverage,
          avg_distance_to_park = avg_park_distances,
          violent_crime_rate = (num_violent_crimes / tot_pop) * 1000,
          has_crime = ifelse(num_violent_crimes > 0, 1, 0),
          has_camera = ifelse(Num_Cameras > 0, 1, 0),
          Cameras_Per_1000 = (Num_Cameras / tot_pop) * 1000
        ) %>%
        relocate(geometry, .after = last_col()) %>%
        st_transform(crs = 'EPSG:4269')
    )
  }) %>%
  bind_rows() %>%
  select(-ends_with('_y')) %>%
  st_transform(crs = 'EPSG:26917') # transform to UTM Zone 17
```

# Results

## Some Variable Maps

```{r some_plots, message=F, warning=F, cache=T}
# plot per capita income by year
ggplot(buff_blocks) + 
  geom_sf(aes(fill = has_camera)) + 
  scale_fill_viridis_c(option = 'inferno') +
  facet_wrap(~year) +
  theme_map()

# plot pct below poverty by year
ggplot(buff_blocks) +
  geom_sf(aes(fill = pct_below_poverty)) +
  scale_fill_viridis_c(option = 'inferno') +
  facet_wrap(~year) +
  theme_map()

# plot pct bachelors degree at least by year
ggplot(buff_blocks) +
  geom_sf(aes(fill = pct_bachelors_deg_at_least)) +
  scale_fill_viridis_c(option = 'inferno') +
  facet_wrap(~year) +
  theme_map()
```

## Bivariate Choropleth Map (Violent Crime Rate and Pct Below Poverty)

Add some text here

```{r bivar_chor_map, message=F, warning=F, cache=T}
# determine classes
bivariate <- bi_class(buff_blocks %>% filter(year == 2023), x = violent_crime_rate, y = pct_below_poverty, 
                      style = 'quantile', dim = 3)

# create legend
bi_legend <- bi_legend(pal = 'GrPink2',
                       dim = 3,
                       xlab = 'Violent Crime Rate',
                       ylab = '% in Poverty',
                       size = 5)

# create map
bi_map <-
  ggplot() +
    geom_sf(data = bivariate, 
            aes(fill = bi_class), 
            color = 'lightgray', 
            show.legend = FALSE) +
    bi_scale_fill(pal = 'GrPink2', dim = 3) +
    bi_theme()

# combine map with legend
final_bi_map <-
  ggdraw() +
    draw_plot(bi_map, 0, 0, 1, 1) +
    draw_plot(bi_legend, 0.15, 0.65, 0.2, 0.2)

final_bi_map
```

Add some text here

## GLMM Model Using glmer

Add some text here

```{r regression, message=F, warning=F}
# specify seed for consistent number generation
set.seed(1234)

# scale quantitative independent variables, then place each observation in a year group
buff_blocks.scaled <- 
  buff_blocks %>%
  mutate(
    per_capita_income = scale(per_capita_income)[,1],
    pct_below_poverty = scale(pct_below_poverty)[,1],
    pct_bachelors_deg_at_least = scale(pct_bachelors_deg_at_least)[,1],
    pct_black_pop = scale(pct_black_pop)[,1],
    pct_park_proximity = scale(pct_park_proximity)[,1],
    avg_distance_to_park = scale(avg_distance_to_park)[,1],
    year_group = case_when(
      year <= 2012 ~ '2010-2012',
      year <= 2015 ~ '2013-2015',
      year <= 2018 ~ '2016-2019',
      TRUE ~ '2020-2023'
    )
  )

# get distinct block group boundaries
bg_spatial <-
  buff_blocks %>%
  distinct(GEOID, .keep_all = TRUE) %>%
  arrange(GEOID)

# create neighbor list and weights
nb <- poly2nb(bg_spatial)
lw <- nb2listw(nb, style = 'W')

# create lag of pct_black_pop
lag_black <- lag.listw(lw, bg_spatial$pct_black_pop)

# add lag to bg_spatial, then select columns and drop geometry
bg_spatial$pct_black_pop_lag <- lag_black

bg_spatial_lag <-
  bg_spatial %>%
  select(GEOID, pct_black_pop_lag) %>%
  st_drop_geometry()

# merge lag data into df for model
buff_blocks.scaled_lagged <-
  buff_blocks.scaled %>%
  left_join(bg_spatial_lag, by = 'GEOID')

# logistic regression with block group as random effect, 
# year_group as fixed effect, spatially lagged covariate of pct_black_pop, 
# and scaled data
model <- glmer(
  has_crime ~ has_camera + per_capita_income + pct_below_poverty +
    pct_bachelors_deg_at_least + pct_black_pop + pct_black_pop_lag + 
    pct_park_proximity + factor(year_group) + (1 | GEOID),
  data = buff_blocks.scaled_lagged,
  family = binomial(link = "logit"),
  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 2e5))
)

#summary(model)
```

In mathematical terms, the model can be expressed as such:

![Violent crime risk predictive GLMM in mathematical form](imgs/glmm_equation.png){fig-alt="Violent crime risk predictive GLMM in mathematical form"}

Where:

* has_crime~it~ is a binary outcome for block group ii in time tt
* β~0~ is the model intercept
* β~1~,…,β~7~ are fixed-effect coefficients for the continuous and binary predictors
* γ~j~​ are coefficients for the year group fixed effects (with one omitted as reference)
* u~i~ ∼ N(0,σ~u~^2^) is the random intercept for block group ii
* I(⋅) is an indicator function for year groups (i.e., dummy variables)

It is imperative to conduct diagnostics tests to assess the model's fit, stability, and potential for interpretation. 

### Diagnostic Tests

```{r regression_diagnostics, message=F, warning=F}
# simulate residuals to help assess model fit,
# then show diagnostic plots
model.simres <- simulateResiduals(model)
plot(model.simres)

#####
# diagnose assumption of normally distributed estimated random effects
#####

# extract random intercepts
random_intercepts <- ranef(model)$GEOID$`(Intercept)`

# qq plot of random effects to check normality
qqnorm(random_intercepts)
qqline(random_intercepts)

#####
# Spatial Autocorrelation (Moran's I test)
#####

# get one row per block group
buff_blocks.ranef <-
  buff_blocks.scaled_lagged %>%
  filter(year == 2023)

# add random intercepts
buff_blocks.ranef$random_intercept <- random_intercepts

# centroids and neighbors
centroids <- st_centroid(buff_blocks.ranef)
coords <- st_coordinates(centroids)
knn <- knearneigh(coords, k = 10) %>% knn2nb()
lw_knn <- nb2listw(knn)

# Moran's I test on random intercept
moran_test <- moran.test(buff_blocks.ranef$random_intercept, lw_knn)

moran_test
```

Diagnostic tests indicate that the generalized linear mixed model (GLMM) fits the data well and that key assumptions are reasonably satisfied. The DHARMa residual diagnostics reveal no significant issues, with residuals closely approximating a uniform distribution. The Kolmogorov–Smirnov test returned a non-significant result (p = 0.671), and neither the dispersion test (p = 0.808) nor the outlier test (p = 0.426) detected evidence of model misfit or overdispersion. These findings suggest that the model’s structure adequately captures the variance in the outcome and that both fixed and random effects are appropriately specified.

Importantly, the spatially lagged percent Black population was included in the model to account for potential spatial dependence in neighborhood-level demographics. This addition helped to alleviate residual spatial autocorrelation, as confirmed by the updated Moran’s I test on the random intercepts. The Moran’s I statistic was small (I = 0.0120) and statistically non-significant (p = 0.2615), indicating that no substantial spatial clustering remains in the unexplained variation across block groups. This suggests that the inclusion of a spatially structured covariate successfully addressed previously unmodeled spatial dependence and improves confidence in the validity of the model’s inferences.

### Fixed Effects

Add some text here

```{r fixed_effects, message=F, warning=F}
###
# odds ratio interpretation
###

# extract fixed effects
# then exponentiate to get odds ratios
fixef_vals <- fixef(model)
odds_ratios <- exp(fixef_vals)

# get standard errors
se_vals <- summary(model)$coefficients[, 'Std. Error']

# compute 95% confidence interval
lower_ci <- exp(fixef_vals - 1.96 * se_vals)
upper_ci <- exp(fixef_vals + 1.96 * se_vals)

# get fixed effects data
fixed_effects <-
  data.frame(
    Estimate = fixef_vals,
    Odds_Ratio = odds_ratios,
    CI_Lower = lower_ci,
    CI_Upper = upper_ci,
    p_value = summary(model)$coefficients[, 'Pr(>|z|)']
  )

# odds ratio table
odds_table <-
  fixed_effects %>%
  mutate(
    Predictor = rownames(.),
    Estimate = round(Estimate, 3),
    Odds_Ratio = round(Odds_Ratio, 2),
    CI = paste0('[', round(CI_Lower, 2), ', ', round(CI_Upper, 2), ']'),
    p_value = formatC(p_value, format = 'e', digits = 2)
  ) %>%
  select(Predictor, Estimate, Odds_Ratio, CI, p_value) %>%
  gt() %>%
  tab_header(
    title = 'Odds Ratios from GLMM Model',
    subtitle = '95% Confidence Intervals and p-values'
  ) %>%
  fmt_markdown(columns = c(CI)) %>%
  cols_label(
    Predictor = 'Predictor',
    Estimate = 'Coefficient',
    Odds_Ratio = 'Odds Ratio',
    CI = '95% CI',
    p_value = 'p-value'
  ) %>%
  tab_options(
    table.font.size = 'small',
    heading.align = 'left'
  )

odds_table

# add signifance to highlight predictors that are significant
fixed_effects_plot_data <-
  fixed_effects %>%
  mutate(
    Predictor = rownames(.),
    Significance = ifelse(p_value < 0.05, 'Significant', 'Not Significant')
  )

# plot fixed effects with confidence intervals and significance
fixed_effects_plt <-
  ggplot(fixed_effects_plot, 
         aes(x = reorder(Predictor, Odds_Ratio), y = Odds_Ratio)) +
  geom_point(aes(color = Significance), size = 3) +
  geom_errorbar(aes(ymin = CI_Lower, ymax = CI_Upper, color = Significance), width = 0.2) +
  geom_hline(yintercept = 1, linetype = 'dashed', color = 'red') +
  scale_y_log10() + # log scale for better visualization
  coord_flip() +
  labs(
    title = 'Odds Ratios with 95% Confidence Intervals',
    subtitle = 'GLMM',
    x = 'Predictor',
    y = 'Odds Ratio (log scale)',
    color = 'Significance'
  ) +
  theme_minimal(base_size = 12)

fixed_effects_plt
```

The generalized linear mixed model (GLMM) presented here estimates the probability of violent crime occurring in a block group using several socio-environmental predictors, while accounting for unobserved heterogeneity across space via random intercepts at the block group (GEOID) level. The model performs well overall, with a relatively low AIC (495.5) and a significant random intercept variance (σ = 2.13), suggesting that baseline crime risk varies meaningfully across block groups even after adjusting for covariates.

Several fixed effects stand out as statistically significant. Most notably, block groups with a surveillance camera had 25 times greater odds of reporting violent crime (OR = 25.10, p = 0.001), which likely reflects reactive placement strategies or a higher probability of detection in surveilled areas rather than a causal effect. Higher per capita income was associated with reduced odds of violent crime (OR = 0.57, p = 0.010), and higher educational attainment (measured by the percentage with at least a bachelor’s degree) was similarly protective (OR = 0.49, p = 0.009), consistent with established socioeconomic theories of crime. Interestingly, the lagged percentage of Black population—a temporally lagged covariate—was associated with substantially higher odds (OR = 65.23, p = 0.049), although the large confidence interval suggests high uncertainty and possible multicollinearity. The current year’s percentage of Black population, in contrast, had no significant effect (p = 0.964), supporting the use of lagged variables to better capture structural or delayed effects.

Other variables, such as poverty and park proximity, did not yield statistically significant associations in this model, and the temporal fixed effects (year groupings) show a clear decline in crime risk over time, particularly in the post-2015 period. For example, the 2020–2023 group had 96% lower odds of violent crime relative to the 2010–2012 baseline (p < 0.001). This temporal decline may reflect broader policing, demographic, or economic shifts occurring citywide.

Overall, the model suggests that crime risk is heavily patterned by structural factors like income and education, and that camera presence strongly correlates with violent incidents—though likely due to endogeneity. The large and significant random effects variance confirms that important localized variation in crime remains unexplained, pointing to the value of spatial random effects in capturing latent neighborhood-level risk.

### Accuracy of Model

Add some text here

```{r accuracy, message=F, warning=F}
###
# accuracy evaluation
###

# get predicted probabilities
pred_probs <- predict(model, type = 'response')

# convert probabilities to binary predictions
pred_class <- ifelse(pred_probs > 0.5, 1, 0)

# create confusion matrix, then extract values
conf_matrix <- table(Predicted = pred_class, Actual = buff_blocks.scaled$has_crime)

TN <- conf_matrix[1,1]
FP <- conf_matrix[2,1]
FN <- conf_matrix[1,2]
TP <- conf_matrix[2,2]

# create confusion matrix dataframe
confusion_df <- tibble(
  Outcome = c('True Negatives', 'False Positives', 
              'False Negatives', 'True Positives'),
  Count = c(TN, FP, FN, TP)
)

# create gt table for confusion matrix
confusion_gt <-
  confusion_df %>%
  gt() %>%
  tab_header(title = 'Confusion Matrix: Crime Prediction Model') %>%
  fmt_number(columns = Count, decimals = 0)

# calculate metrics
accuracy <- (TP + TN) / sum(conf_matrix)
sensitivity <- TP / (TP + FN)
specificity <- TN / (TN + FP)

# create metrics dataframe
metrics_df <- tibble(
  Metric = c('Accuracy', 'Sensitivity (Recall)', 'Specificity'),
  Value = c(accuracy, sensitivity, specificity)
)

# create gt table for metrics
metrics_gt <- 
  metrics_df %>%
  mutate(Value = round(Value, 4)) %>%
  gt() %>%
  tab_header(title = 'Model Performance Metrics') %>%
  fmt_percent(columns = Value, decimals = 2)

# show gt tables of confusion matrix and metrics
confusion_gt
metrics_gt
```

The performance metrics for the crime prediction model indicate a high overall accuracy of 98.3%, suggesting that the model correctly predicts whether violent crime occurred in the vast majority of cases. However, this figure is heavily influenced by the model’s excellent sensitivity (99.75%), meaning it is highly effective at identifying block groups where at least one violent crime occurred. In contrast, the model’s specificity is much lower (28.92%), indicating it struggles to correctly classify block groups where no violent crime took place. This imbalance reflects a highly skewed outcome distribution where most block groups experience at least one violent crime during a given year, and highlights the model's bias toward predicting the presence of crime. Indeed, of the 4,060 total observations in the dataset (reflecting 290 uniform census block group boundaries over a 14-year period), only 83 (~ 2%) had no violent crime. While such high sensitivity is desirable in risk screening contexts, the low specificity suggests that the model may overestimate risk in safer areas, potentially leading to false alarms or inefficient allocation of preventive resources if used for intervention targeting.

### Random Effects

Add some text here

#### Block Group-Level

```{r random_effects_bg, message=F, warning=F}
# make map of random effects to see which areas have a higher risk of crime
# than expected possibly due to unmeasured factors, and which areas have lower
# than expected crime risk
ranef_map <-
  ggplot(buff_blocks.ranef) +
  geom_sf(aes(fill = random_intercept), color = NA) +
  scale_fill_distiller(
    palette = 'RdYlBu',
    name = 'Random Intercept\n(Log-Odds)',
    na.value = 'grey80',
    direction = -1
  ) +
  labs(
    title = 'Random Effects by Block Group',
    subtitle = 'Baseline Crime Risk After Controlling for Predictors'
  ) +
  theme_map()

ranef_map
```

#### Investigating Persistent Positive Random Effects by Neighborhood

```{r random_effects_neighborhood, message=F, warning=F}
# see where block groups and neighborhoods intersect
# calculate area of each intersected piece
bg_neighborhoods_overlap <- 
  st_intersection(buff_blocks.ranef, 
                  st_transform(buff_neighborhoods, 
                               crs = st_crs(buff_blocks.ranef))) %>%
  mutate(overlap_area = st_area(.)) %>%
  st_transform(crs = st_crs(buff_blocks.ranef))

# for each block group, keep the neighborhood where the overlap is largest
bg_neighborhoods <- 
  bg_neighborhoods_overlap %>%
  group_by(GEOID) %>%
  slice_max(overlap_area) %>%
  ungroup() %>%
  .[,-c(2:45)] %>%
  rename(area_sqmi = `area_sqmi.1`)

# compute average and maximum random intercept and number of block groups
# for each neighborhood
ranef_summary <-
  bg_neighborhoods %>%
  st_drop_geometry() %>%
  group_by(neighborhood_name) %>%
  summarize(
    avg_random_effect = mean(random_intercept, na.rm = TRUE),
    max_random_effect = max(random_intercept, na.rm = TRUE),
    num_blockgroups = n()
  )

# merge buffalo neighborhoods with their random effects summary data
neighborhood_ranef <- 
  left_join(buff_neighborhoods, 
            ranef_summary, 
            by = 'neighborhood_name') %>%
  st_transform(crs = st_crs(buff_blocks.ranef))

# show table of avg random effects in descending order
neighborhood_ranef %>%
  st_drop_geometry %>%
  arrange(desc(avg_random_effect)) %>%
  gt()

# identify top 5 most at-risk neighborhoods, then get their centroids
# for labeling of top 5 most at-risk neighborhoods on the map
top5_neighborhoods <-
  neighborhood_ranef %>%
  arrange(desc(avg_random_effect)) %>%
  slice_head(n = 5)

top5_centroids <- st_centroid(st_transform(top5_neighborhoods, 
                                           crs = st_crs(buff_blocks.ranef)))

# map neighborhood-level random effects
neighborhood_ranef_map <-
  ggplot(neighborhood_ranef) +
    geom_sf(aes(fill = avg_random_effect), color = 'white') +
    scale_fill_distiller(
      palette = 'RdYlBu',
      name = 'Random Intercept\n(Log-Odds)',
      na.value = 'grey80',
      direction = -1,
      limits = c(
        min(neighborhood_ranef$avg_random_effect),
        max(neighborhood_ranef$avg_random_effect)
      )
    ) +
  geom_sf_text(
    data = top5_centroids,
    aes(label = neighborhood_name),
    size = 2, color = 'black', fontface = 'bold'
  ) +
    labs(
      title = 'Average Unexplained Crime Risk by Neighborhood',
      subtitle = 'Based on Random Intercepts from Mixed-Effects Model'
    ) +
    theme_map()

neighborhood_ranef_map
```

### High Unexplained Risk Block Groups vs. Current Police Cameras

Add some text here

```{r where_to_put_camera, message=F, warning=F}
# create map of random effects with full bpd cameras dataset overlayed on top
ranef_cams_map <-
  ggplot() +
  geom_sf(data = buff_blocks.ranef, aes(fill = random_intercept), color = NA) +
  geom_sf(data = bpd_cameras %>% 
            st_transform(crs = st_crs(buff_blocks.ranef)), 
          color = 'black') +
  scale_fill_distiller(
    palette = 'RdYlBu',
    name = 'Random Intercept\n(Log-Odds)',
    na.value = 'grey80',
    direction = -1
  ) +
  labs(
    title = 'Crime Risk by Block Group',
    subtitle = 'BPD Surveillance Camera Locations'
  ) +
  theme_map()
  
ranef_cams_map

# get top-30 block groups in terms of highest random intercept
top_30_bgs <-
  buff_blocks.ranef %>%
  select(GEOID, has_camera, random_intercept, geometry) %>%
  arrange(desc(random_intercept)) %>%
  head(n = 30)

# map of top-30 block groups in terms of highest random intercept
top_30_bgs_map <-
  ggplot() +
  geom_sf(data = buff_border %>% 
            st_transform(crs = st_crs(top_30_bgs)), 
          color = 'black', fill = 'white') +
  geom_sf(data = top_30_bgs, aes(fill = random_intercept)) +
  geom_sf(data = bpd_cameras %>% 
            st_transform(crs = st_crs(top_30_bgs)),
          color = 'black') +
  scale_fill_distiller(
    palette = 'RdYlBu',
    name = 'Random Intercept\n(Log-Odds)',
    na.value = 'grey80',
    direction = -1
  ) +
  labs(
    title = 'Block Groups with Most Unexplained Violent Crime Risk',
    subtitle = 'Top 30 with BPD Surveillance Camera Locations'
  ) +
  theme_map()

top_30_bgs_map
```

The series of maps presented provide a multifaceted view of spatial patterns in violent crime risk across Buffalo's block groups, drawing from the random intercepts of the generalized linear mixed model (GLMM). These random intercepts represent the portion of violent crime likelihood not explained by observed covariates—effectively highlighting “baseline” or unexplained risk.

The first map “Random Effects by Block Group” displays the raw random intercepts at the block group level. Warmer colors (orange/red) indicate block groups where the model's baseline log-odds of violent crime are elevated even after adjusting for covariates like poverty, race, income, and education, while cooler colors (blue) indicate lower-than-expected baseline risk. Spatial clustering of high-risk areas is evident in portions of the city’s east and south sides, suggesting unmeasured or place-based factors at play, such as historic disinvestment or informal criminal economies, which are not captured by the included predictors.

The second map “Average Unexplained Crime Risk by Neighborhood” aggregates these random effects to the neighborhood level to reveal broader patterns. Notably, neighborhoods like Black Rock, Hopkins-Tifft, and parts of Broadway-Fillmore and Seneca-Babcock exhibit high average unexplained risk, whereas northern and central neighborhoods such as North Park or Delaware Park show consistently lower baseline risk. This reinforces the existence of durable spatial inequalities in violence risk that persist beyond the influence of typical socioeconomic variables.

The third map “Crime Risk by Block Group with BPD Cameras” overlays surveillance camera locations atop the random effects surface. There is no clear visual correspondence between camera locations and elevated baseline crime risk—many high-risk areas remain underserved by surveillance infrastructure, while some lower-risk areas host clusters of cameras. This misalignment raises concerns about the spatial allocation efficiency of the Buffalo Police Department’s surveillance network and whether it aligns with underlying risk patterns.

The last map “Top 30 Block Groups with Most Unexplained Risk” isolates the block groups with the highest positive random intercepts, which are block groups where crime risk is most under-predicted by the model. Interestingly, many of these high-risk areas are found in the northern and eastern parts of the city and tend to overlap only partially with surveillance coverage. The fact that these locations exhibit excess crime risk that is not well-explained by socioeconomic indicators suggests the influence of unobserved local dynamics or spatial spillover effects.

Together, these maps imply that while known predictors explain much of the variation in violent crime across Buffalo, persistent pockets of unexplained high risk remain. These areas merit further investigation and could represent strategic priorities for resource allocation, targeted interventions, or community engagement—especially where gaps in surveillance or prevention infrastructure are evident.

# Discussion and Conclusions

The built environment also plays a crucial role in influencing crime patterns. De Nadai et al. (2020) utilized a Bayesian model to explore how violent and property crimes are related not only to socio-economic factors but also to the built environment and mobility characteristics of neighborhoods. The findings suggest that areas with certain land use patterns and mobility conditions may experience higher crime rates.

Evaluating the efficacy of police surveillance cameras on mitigating violent crime could be studied through the fitting of a differences-in-differences (DiD) model.....
- My attempt to perform a difference-in-difference regression analysis were unsuccessful. The estimated model would automatically remove the coefficients calculated for the years prior to installation due to collinearity, so the model could not effectively compare violent crime rates from pre-installation years to post-installation years. This could partially be due to incomplete data, especially with installation dates. Many police cameras do not have installed dates, so I assumed these ones were installed after 2017 (the last year accounted for in the dataset). This assumption introduces bias and it would be preferable to at least figure out the meaning/reasoning behind these missing installation dates to better account for it in the model, assuming it would be possible.

Does not differentiate between different categories of violent crime (homicides, assaults robberies, sex offenses) and instead treats them all as one cohesive category.

There may be better methods of interpolation... (CITATION)
  - population-weighted areal interpolation through centroid assignment seems to have been adequate for the purposes of this study
  
Could look at other variables that could possibly measure social cohesion, such as 311 reports (CITATION). Unfortunately, while extensive, the available 311 data through Open Data Buffalo is incomplete and has many missing values that rendered it incredibly difficult to incorporate into this analysis.
- Could also incorporate other variables (FIND SOME)

# References

## Works Cited

Anselin, L., Cohen, J., Cook, D., Gorr, W., & Tita, G. (2000). Spatial analyses of crime. *Criminal Justice*, *4*, 213-262. <https://www.ojp.gov/criminal_justice2000/vol_4/04e.pdf>

Bates, D., Mächler, M., Bolker, B., Walker, S. (2015). “Fitting Linear Mixed-Effects Models Using lme4.” *Journal of Statistical Software*, *67*(1), 1–48. <https://doi.org/10.18637/jss.v067.i01>.

Benson, M.L. and Fox, G.L. (2004). Concentrated Disadvantage, Economic Distress, and Violence Against Women in Intimate Relationships. *Office of Justice Programs*. Retrieved from <https://www.ojp.gov/pdffiles1/nij/199709.pdf>.

Bolker, B. M., Brooks, M. E., Clark, C. J., Geange, S. W., Poulsen, J. R., Stevens, M. H. H., & White, J.-S. S. (2009). Generalized linear mixed models: a practical guide for ecology and evolution. *Trends in Ecology & Evolution*, *24*(3), 127–135. <https://doi.org/10.1016/j.tree.2008.10.008>

De Nadai, M., Xu, Y., Letouzé, E., González, M.C., & Lepri, B. (2020). Socio-economic, built environment, and mobility conditions associated with crime: a study of multiple cities. *Scientific Reports*, *10*(13871). <https://doi.org/10.1038/s41598-020-70808-2>

Hartig, F. (2024). DHARMa: Residual Diagnostics for Hierarchical (Multi-Level / Mixed) Regression Models. R package version 0.4.7, <https://github.com/florianhartig/dharma>.

Hollander, J.B. & Cahill, B. (2011). Confronting Population Decline in the Buffalo, New York, Region: A Close Reading of the "Erie-Niagara Framework for Regional Growth". *Journal of Architectural and Planning Research*, *28*(3), 252-267. <https://www.jstor.org/stable/43030944>

Klinenberg, E. (2002). Heat Wave: A Social Autopsy of Disaster in Chicago. University of Chicago Press. <https://press.uchicago.edu/ucp/books/book/chicago/H/bo20809880.html>

Kraus, N. (2004). Local policymaking and concentrated poverty: the case of Buffalo, New York. *Cities*, *21*(6), 481-490. <https://doi.org/10.1016/j.cities.2004.08.004>

Krivo, L. J. & Peterson, R. D. (1996). Extremely disadvantaged neighborhoods and urban crime. *Social Forces*, *75*(2), 619-648. <https://doi.org/10.1093/sf/75.2.619>

Lum, C., Koper, C. S., & Willis, J. J. (2019). Understanding the limits of technology’s impact on police effectiveness. *Police Quarterly*, *22*(2), 189–213. <https://doi.org/10.1177/1098611116667279>

Manson, S., Schroeder, J., Van Riper, D., et al. (2024). IPUMS National Historical Geographic Information System: Version 19.0 [dataset]. Minneapolis, MN: IPUMS. <http://doi.org/10.18128/D050.V19.0>

Marotta, P. (2016). Assessing Spatial Relationships Between Rates of Crime and Rates of Gonorrhea and Chlamydia in Chicago, 2012. *Journal of Urban Health*, *94*, 276-288. <https://doi.org/10.1007/s11524-016-0080-7>

Office of Justice Programs. (2019). CCTV Surveillance for Crime Prevention: A 40-Year Systematic Review with Meta-Analysis. Retrieved from <https://www.ojp.gov/library/publications/cctv-surveillance-crime-prevention-40-year-systematic-review-meta-analysis>.

Park, Y.M. & Kim, Y. (2014). A spatially filtered multilevel model to account for spatial dependency: application to self-rated health status in South Korea. *International Journal of Health Geographies*, *13*(6). <https://doi.org/10.1186/1476-072X-13-6>

Piza, E. L. (2018). The crime prevention effect of CCTV in public places: A propensity score analysis. *Journal of Criminal Justice*, *57*, 42–50. Retrieved from <https://academicworks.cuny.edu/cgi/viewcontent.cgi?article=1188&context=jj_pubs>.

Reich, B. J., Hodges, J. S., & Zadnik, V. (2006). Effects of residual smoothing on the posterior of the fixed effects in disease-mapping models. *Biometrics*, *62*(4), 1197–1206. <https://doi.org/10.1111/j.1541-0420.2006.00617.x>

Ryan, B. D. (2015). Design after Decline: How America Rebuilds Shrinking Cities. University of Pennsylvania Press. <https://www.pennpress.org/9780812223040/design-after-decline/>

Sampson, R. J. & Groves, W. B. (1989). Community structure and crime: Testing social-disorganization theory. *American Journal of Sociology*, *94*(4), 774-802. <https://doi.org/10.1086/229068>

Sampson, R. J., Raudenbush, S. W., & Earls, F. (2002). Neighborhoods and violent crime: A multilevel study of collective efficacy. *Science*, *277*(5328), 918–924. <https://doi.org/10.1126/science.277.5328.918>

Sariaslan, A., Långström, N., D'Onofrio, B., et al. (2013). The impact of neighbourhood deprivation on adolescent violent criminality and substance misuse: A longitudinal, quasi-experimental study of the total Swedish population. *International Journal of Epidemiology*, *42*(4), 1057-1066. <https://doi.org/10.1093/ije/dyt066>

Scorsone, E. and Bateson, N. (2011). *Long-Term Crisis and Systemic Failure: Taking the Fiscal Stress of American Cities Seriously (Case Study: City of Flint, Michigan)*. East Lansing, MI: Michigan State University. Retrieved from <https://www.cityofflint.com/wp-content/uploads/Reports/MSUE_FlintStudy2011.pdf>.

Weisburd, D. (2015). The law of crime concentration and the criminology of place. *Criminology*, *53*(2), 133-157. <https://doi.org/10.1111/1745-9125.12070>

Welsh, B. C., & Farrington, D. P. (2009). Public area CCTV and crime prevention: An updated systematic review and meta‐analysis. *Justice Quarterly*, *26*(4), 716-745.<https://doi.org/10.1080/07418820802506206>

Wu, L., Li, N. (2024). Neighborhood effects and consequences of criminal justice contact: a research framework. *Computational Urban Science*, *4*(27). <https://doi.org/10.1007/s43762-024-00138-w>

U.S. Census Bureau. (2020). American Community Survey 5-Year Estimates. Retrieved from https://www.census.gov.

Urban Institute. (2019). Public Surveillance Cameras and Crime. Retrieved from <https://www.urban.org/sites/default/files/publication/101649/public_surveillance_cameras_and_crime.pdf>.

Walker, K. (2023). "7.3 Small area time-series analysis," in *Analyzing US Census Data: Methods, Maps, and Models in R*. CRC Press: Boca Raton, Florida. Retrieved from <https://walker-data.com/census-r/spatial-analysis-with-us-census-data.html#small-area-time-series-analysis>.

Walker, K. & Herman, M. (2025). tidycensus: Load US Census Boundary and Attribute Data as 'tidyverse' and 'sf'-Ready Data Frames. R package version 1.7.1, <https://walker-data.com/tidycensus/>. 

Wirdze, L. (2024). Impact of Income Inequality on Crime Rates in Urban Areas. *European Journal of Sociology*, *7*(1), 43-53. <https://doi.org/10.47672/ejs.2373>





https://onlinelibrary.wiley.com/doi/full/10.1002/pam.22280

https://www.scup.com/doi/full/10.1080/14043858.2017.1387410

https://academicworks.cuny.edu/cgi/viewcontent.cgi?article=1188&context=jj_pubs

https://www.ojp.gov/pdffiles1/nij/grants/236740.pdf

https://onlinelibrary.wiley.com/doi/pdf/10.1111/sjoe.12075?casa_token=SX3xVt6EgFkAAAAA:eODmQosuKP0zjBJfhe_Y-gz-IyI6oz6ZYAhCTk592B_QPIToQtstGwP4iA2_2oDOn7d7qe74CCFqt-o

https://academic.oup.com/ej/article-abstract/125/588/F289/5077916?casa_token=pCc5yt9EQN8AAAAA%3AWICtxUWaGBe19xoqxnfbcGgOqP0b1BnIwrI1Ad5DDyH7Rtjhq1B-aZ_KCLyy_usWw1APxdRhtad-xA

## Data Sources

Crime: https://data.buffalony.gov/Public-Safety/Crime-Incidents/d6g9-xbgu/about_data
Cameras: https://data.buffalony.gov/Public-Safety/BPD-Cameras/egev-8jf4

City Parks: https://data.buffalony.gov/Quality-of-Life/Parks/b6ah-eygb
County Parks: https://www3.erie.gov/gis/map-gallery
State Parks: https://data.gis.ny.gov/maps/nysparks::ny-state-parks-property/about

Police Stations: https://data.buffalony.gov/Public-Safety/BPD-Stations/yjub-v64n/about_data

City Boundary: https://data.buffalony.gov/Government/City-Boundary/kkz7-hj9w

ACS data: 5-year ACS estimates pulled using tidycensus package
